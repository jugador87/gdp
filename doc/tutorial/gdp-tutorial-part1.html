<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Introduction to the Global Data Plane</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Introduction to the Global Data Plane</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#global-data-plane-gdp">Global Data Plane (GDP)</a><ul>
<li><a href="#writes-and-reads">Writes and Reads</a></li>
<li><a href="#addressing">Addressing</a></li>
<li><a href="#client-side-implementation">Client side implementation</a></li>
<li><a href="#security-and-privacy">Security and Privacy</a></li>
</ul></li>
</ul>
</div>
<p>For any questions about this document, send comments to:</p>
<ul>
<li>Nitesh Mor, U.C. Berkeley Ubiquitous Swarm Lab, <script type="text/javascript">
<!--
h='&#x65;&#x65;&#x63;&#x73;&#46;&#98;&#x65;&#114;&#x6b;&#x65;&#108;&#x65;&#x79;&#46;&#x65;&#100;&#x75;';a='&#64;';n='&#x6d;&#x6f;&#114;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x6d;&#x6f;&#114;&#32;&#x61;&#116;&#32;&#x65;&#x65;&#x63;&#x73;&#32;&#100;&#x6f;&#116;&#32;&#98;&#x65;&#114;&#x6b;&#x65;&#108;&#x65;&#x79;&#32;&#100;&#x6f;&#116;&#32;&#x65;&#100;&#x75;</noscript></li>
<li>Eric Allman, U.C. Berkeley Ubiquitous Swarm Lab, <script type="text/javascript">
<!--
h='&#x63;&#x73;&#46;&#98;&#x65;&#114;&#x6b;&#x65;&#108;&#x65;&#x79;&#46;&#x65;&#100;&#x75;';a='&#64;';n='&#x65;&#114;&#x69;&#x63;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x65;&#114;&#x69;&#x63;&#32;&#x61;&#116;&#32;&#x63;&#x73;&#32;&#100;&#x6f;&#116;&#32;&#98;&#x65;&#114;&#x6b;&#x65;&#108;&#x65;&#x79;&#32;&#100;&#x6f;&#116;&#32;&#x65;&#100;&#x75;</noscript></li>
</ul>
<hr />
<p>This is a brief high level introduction to the Global Data Plane, primarily for users wishing to incorporate GDP in their existing applications. It is a living document, subject to change. In particular we are planning on some major new functionality which will partly change the interface.</p>
<h1 id="introduction">Introduction</h1>
<p>Let’s imagine you have a tiny little sensor that measures temperature periodically and spits out the current temperature. To make this sensor <em>smart</em>, we add some communication capabilities to it. But how do you use the data generated by this sensor?</p>
<p>Next, let’s imagine we put the data generated by the sensor in a log-file. A new temperature reading gets appended to this file as the sensor generates new data. With the log-file approach, we suddenly get quite a few new capabilities—a user can look at the log file to see historic values, query it for the latest reading, and so on—all this without adding any functionality in the sensor itself. As a matter of fact, you don’t even need to know about the real sensor anymore; a log file virtualizes this sensor in a way.</p>
<p>Next, imagine that we have an actuator. The actuation happens when the actuator receives a certain command over some communication channel. Let’s apply the log-file approach to the actuator too—the actuator is <em>subscribed</em> to a log-file (subscription just means that the actuator receives any new data in a particular log-file as it arrives). This gives us a way to virtualize the actuator as well. Anyone intending to actuate a particular actuator only needs to write the actuation data to a log-file.</p>
<h1 id="global-data-plane-gdp">Global Data Plane (GDP)</h1>
<p>In the GDP, we take this basic abstraction of a log and use this as a communication and storage mechanism for various entities producing/consuming data. In GDP, a log is nothing more than a place where you can write records (each called a datum) in a queue/list like fashion. Any structure in the datum is assigned by your program; a datum is just an opaque blob of data for the GDP. Other than the real data, each datum has a sequence number (starting from one), a timestamp, and potentially other metadata (TBD). Logs have some metadata that tells some general information about the log, e.g. a public key for checking signatures (Details TBD). Metadata can only be specified when the log is created.</p>
<div class="figure">
<img src="log-structure-1.png" alt="Logical representation of GDP log" />
<p class="caption">Logical representation of GDP log</p>
</div>
<p>As for the different software components, there are clients (readers/writers), routers and log-servers. As a user, you probably need to know only about the client side. However, just for a little better understanding of the entire system—a log-server (gdplogd) is a server process that actually stores the data and responds to commands for reading/writing etc. A router (gdp-router), as the name implies, routes all the GDP traffic appropriately. As a client interested in a particular log, you connect to <em>any</em> router over a TCP channel. It is the job of the router to figure out what log-server hosts the log in question and then route all the communication.</p>
<div class="figure">
<img src="gdp-components.png" alt="GDP software components" />
<p class="caption">GDP software components</p>
</div>
<h2 id="writes-and-reads">Writes and Reads</h2>
<p>The write operation for the logs is <em>append</em>. A datum written to the log can not be over-written. As of now, neither logs nor records expire (one or both may change in future). There are two versions of append available in the library provided: synchronous and asynchronous, however they are just two different ways of implementing the same underlying operation. In synchronous operation, a writer waits for an acknowledgment before commencing the next append operation. This might not be the most efficient way to go about for applications with high performance requirements, hence the asynchronous operation where the writer can have multiple append operations in transit at a time. However, note that the synchronous vs asynchronous operation is purely a difference in how the client library processes the data—internally all operations are asynchronous.</p>
<p>The read operation can be performed in a couple of different ways—read a single record by a record number, read multiple records together with a single read request, or subscribe to a log to be notified of potential future data. However, querying a record by the record number is not the best way for all the situations, because often times the latest few values in a log are of interest. The question is: as a reader, how are you supposed to know the record number to be used. For this reason, the record number for a read request can take a negative value to address the records from most recent first. For instance, record number -1 refers to the most recent record in a log.</p>
<p>Another important thing to note is that the logs are supposed to be single-writer—each sensor has their own log. This makes quite a few things easier for us (encryption, signatures, data-ordering, etc.). However, there are situations where a composite log is desired, such as one log for all the temperature sensors in a building. We envision that a simple service can subscribe to all the individual logs, possibly perform some kind of operation on those values (for example, calculating average temperature in a building), and then write those values to a <em>composite</em> log. A <em>composite</em> log is again a single writer log where the particular service is the sole writer to the <em>composite</em> log.</p>
<h2 id="addressing">Addressing</h2>
<p>All objects known to the GDP, including logs and services, exist in a single, flat, global namespace based on 256-bit numbers (loosely referred to as the internal name). These are assigned by the GDP when the log is created using a hash of the metadata and public key (the exact composition of this is TBD). <em>(At the moment it is possible to specify the data that is hashed for the name, but this will be changed soon).</em> A directory service will map human-understandable names into internal names (coming soon).</p>
<!--

All communications in the GDP are provided by the GDP Routing Layer.  At the
moment the implementation has limited scalability and does not work with
routers behind NAT firewalls.  We are planning on dropping the second
restriction soon, but the truly global, scalable, peer-to-peer based
implementation will take a bit longer.

At the moment, logs must be created by hand on a specific log server.  This
will be replaced by a log creation service soon.  To have a log created,
contact Eric (eric@cs.berkeley.edu).

-->
<h2 id="client-side-implementation">Client side implementation</h2>
<p>As of now, at the core of client side distribution is a C library. There are wrappers around the C library for Python and Java. Wrappers for other languages tend to run slightly behind in features compared to the C interface, however, you might find them an easier option if you want an object oriented interface or are not comfortable programming in C.</p>
<p>Java interface is moderately supported. Contact Nitesh (<script type="text/javascript">
<!--
h='&#x65;&#x65;&#x63;&#x73;&#46;&#98;&#x65;&#114;&#x6b;&#x65;&#108;&#x65;&#x79;&#46;&#x65;&#100;&#x75;';a='&#64;';n='&#x6d;&#x6f;&#114;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x6d;&#x6f;&#114;&#32;&#x61;&#116;&#32;&#x65;&#x65;&#x63;&#x73;&#32;&#100;&#x6f;&#116;&#32;&#98;&#x65;&#114;&#x6b;&#x65;&#108;&#x65;&#x79;&#32;&#100;&#x6f;&#116;&#32;&#x65;&#100;&#x75;</noscript>) if you are in desperate need for a Java interface. There is also a REST-based interface, which is covered elsewhere.</p>
<h2 id="security-and-privacy">Security and Privacy</h2>
<p>The long-term plan is to use encryption for data secrecy and signatures for authenticity. Ideally, a user reading/writing data from/to GDP should not have to trust any other component of the system for any verification (not even the log servers). We envision that we can achieve such guarantees by making the client side a little smarter and using mathematical techniques such as encryption. However, it is a work in progress and in the current stage, we do not provide any such guarantees.</p>
<p>As mentioned earlier, logs are single-writer. Roughly, each log has a public signature key included in the log-level metadata; the private part stays with the intended writer of the log. All the writes are signed using the private signature key which are verified by the log-server to enforce 1) write access control, 2) data authenticity. These signatures are included in the on-disk data and could be queried by a client to make sure that the data was not modified in any way. Any tampering with record ordering can also be detected, since the single-writer model allows for the writer to create an implicit linked-list protected by signatures. However, this is only partly implemented as of now.</p>
<p>Encryption is used to make data available to only certain users. Ideally, anyone can read encrypted data but can not make any sense out of it without access to the decryption key. However, there are limitations to this approach. Side channels, weak encryption, key-management are some of the many challenges that need to be solved.</p>
<p>As for the overhead of signatures/encryption, in the current phase we envision that if a device can speak the GDP protocol, it can also perform signature/encryption. Ultra low power devices might offload the entire process to a more powerful gateway device (a smartphone, for instance).</p>
<!-- Ideally devices will have a key-pair assigned at the factory with only the
public key exposed, although low-power crypto-unaware devices may speak to a
gateway that (optionally) collects data from multiple devices and then signs
and encrypts the data before submitting it to the GDP.

Security is enforced by cryptographic techniques — for example, there are no
ACLs.

Starting from the data acquisition device (for example, a sensor), the model is
that each device will have a key pair created at the factory.  The secret key
will be burned into the device and not be accessible.  Each device has a
corresponding log, and the public key for the device will be included in the
log metadata when the log is created.  The device will sign all outgoing
records using the secret key, and the GDP log server hosting the log will check
the signature before writes are permitted.  The signature is retained with
record, so consumers (readers) may verify the signature themselves.  Very small
and/or low power devices that can not sign themselves will have an intermediate
gateway that does the signing, at the risk of lowered security should the
gateway be compromised or if a Man In The Middle attack can be raised between
the sensor and the gateway.  -->
</body>
</html>
